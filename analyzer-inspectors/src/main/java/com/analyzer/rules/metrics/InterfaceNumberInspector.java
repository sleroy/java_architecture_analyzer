package com.analyzer.rules.metrics;

import com.analyzer.api.inspector.InspectorDependencies;
import com.analyzer.core.inspector.InspectorTags;
import com.analyzer.core.export.NodeDecorator;
import com.analyzer.api.graph.GraphRepository;
import com.analyzer.api.graph.JavaClassNode;
import com.analyzer.core.resource.JARClassLoaderService;
import com.analyzer.dev.inspectors.classloader.AbstractClassLoaderBasedInspector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

/**
 * Inspector that analyzes the number of interfaces implemented by Java classes
 * using runtime class loading.
 * 
 * <p>
 * This inspector uses runtime class loading to count both direct and inherited
 * interface implementations. It provides comprehensive metrics including total
 * interface count, direct implementation count, and inherited interface count.
 * </p>
 * 
 * <p>
 * Key features:
 * </p>
 * <ul>
 * <li>Interface deduplication using HashSet for proper counting</li>
 * <li>Framework-specific pattern detection (Spring, JPA, EJB)</li>
 * <li>Comprehensive interface hierarchy analysis</li>
 * <li>Architectural complexity scoring based on interface usage</li>
 * </ul>
 * 
 * <p>
 * Metrics are attached to the JavaClassNode for architectural analysis and
 * migration planning.
 * </p>
 * 
 * <p>
 * Operates in Phase 4 on JavaClassNode objects.
 * </p>
 * 
 * @author Generated by EJB Migration Analyzer
 * @since Phase 2.4 - ClassLoader-Based Metrics
 */
@InspectorDependencies(requires = { InspectorTags.TAG_JAVA_DETECTED, InspectorTags.TAG_APPLICATION_CLASS }, produces = {
        "interfaces.total_count" })
public class InterfaceNumberInspector extends AbstractClassLoaderBasedInspector {

    private static final Logger logger = LoggerFactory.getLogger(InterfaceNumberInspector.class);

    // Property keys for JavaClassNode metrics
    public static final String PROP_INTERFACES_TOTAL_COUNT = "interfaces.total_count";
    public static final String PROP_INTERFACES_DIRECT_COUNT = "interfaces.direct_count";
    public static final String PROP_INTERFACES_INHERITED_COUNT = "interfaces.inherited_count";
    public static final String PROP_INTERFACES_COMPLEXITY_SCORE = "interfaces.complexity_score";
    public static final String PROP_INTERFACES_HAS_FRAMEWORK = "interfaces.has_framework";
    public static final String PROP_INTERFACES_FRAMEWORK_TYPES = "interfaces.framework_types";

    // Analysis thresholds and weights
    private static final int COMPLEX_INTERFACE_THRESHOLD = 5;
    private static final double DIRECT_INTERFACE_WEIGHT = 1.0;
    private static final double INHERITED_INTERFACE_WEIGHT = 0.5;
    private static final double FRAMEWORK_INTERFACE_WEIGHT = 1.5;

    // Framework interface patterns
    private static final Set<String> SPRING_INTERFACES = Set.of(
            "org.springframework.stereotype.Component",
            "org.springframework.stereotype.Service",
            "org.springframework.stereotype.Repository",
            "org.springframework.stereotype.Controller",
            "org.springframework.web.bind.annotation.RestController",
            "org.springframework.boot.ApplicationRunner",
            "org.springframework.boot.CommandLineRunner");

    private static final Set<String> JPA_INTERFACES = Set.of(
            "javax.persistence.Entity",
            "javax.persistence.Embeddable",
            "org.springframework.data.repository.Repository",
            "org.springframework.data.jpa.repository.JpaRepository",
            "org.springframework.data.repository.CrudRepository");

    private static final Set<String> EJB_INTERFACES = Set.of(
            "javax.ejb.SessionBean",
            "javax.ejb.EntityBean",
            "javax.ejb.MessageDrivenBean",
            "javax.ejb.Remote",
            "javax.ejb.Local",
            "javax.ejb.LocalHome",
            "javax.ejb.RemoteHome");

    private final GraphRepository graphRepository;

    /**
     * Creates a new InterfaceNumberInspector with required dependencies.
     * 
     * @param classLoaderService the service providing the shared ClassLoader
     * @param graphRepository    the graph repository for storing analysis results
     */
    @Inject
    public InterfaceNumberInspector(JARClassLoaderService classLoaderService,
            GraphRepository graphRepository) {
        super(classLoaderService);
        this.graphRepository = graphRepository;
    }

    @Override
    public String getName() {
        return "InterfaceNumberInspector";
    }

    @Override
    protected void analyzeLoadedClass(Class<?> loadedClass, JavaClassNode classNode,
            NodeDecorator<JavaClassNode> decorator) {
        try {
            logger.debug("Analyzing interface implementations for class: {}", loadedClass.getName());

            // Calculate comprehensive interface metrics
            InterfaceMetrics metrics = calculateInterfaceMetrics(loadedClass);

            // Perform framework-specific analysis
            analyzeFrameworkInterfaces(loadedClass, metrics);

            // Calculate complexity score
            metrics.complexityScore = calculateComplexityScore(metrics);

            // Attach metrics to JavaClassNode
            decorator.setProperty(PROP_INTERFACES_TOTAL_COUNT, metrics.totalCount);
            decorator.setProperty(PROP_INTERFACES_DIRECT_COUNT, metrics.directCount);
            decorator.setProperty(PROP_INTERFACES_INHERITED_COUNT, metrics.inheritedCount);
            decorator.setProperty(PROP_INTERFACES_COMPLEXITY_SCORE, metrics.complexityScore);
            decorator.setProperty(PROP_INTERFACES_HAS_FRAMEWORK, metrics.hasFrameworkInterfaces);

            if (!metrics.frameworkTypes.isEmpty()) {
                decorator.setProperty(PROP_INTERFACES_FRAMEWORK_TYPES, String.join(",", metrics.frameworkTypes));
            }

            if (metrics.totalCount >= COMPLEX_INTERFACE_THRESHOLD) {
                decorator.setProperty("interfaces.pattern", "complex_implementation");
            }

            if (metrics.hasFrameworkInterfaces) {
                decorator.setProperty("interfaces.pattern", "framework_integration");
            }

            logger.debug("Successfully analyzed {} total interfaces for class: {}",
                    metrics.totalCount, loadedClass.getName());

        } catch (Exception e) {
            logger.warn("Error analyzing interface implementations for class: {} - {}",
                    loadedClass.getName(), e.getMessage());
            decorator.error("Failed to analyze interface implementations: " + e.getMessage());
        }
    }

    /**
     * Calculates comprehensive interface metrics for the given class.
     * 
     * @param clazz the class to analyze
     * @return interface metrics including counts and detailed information
     */
    private InterfaceMetrics calculateInterfaceMetrics(Class<?> clazz) {
        InterfaceMetrics metrics = new InterfaceMetrics();

        // Get direct interfaces
        Set<Class<?>> directInterfaces = new HashSet<>(Arrays.asList(clazz.getInterfaces()));
        metrics.directCount = directInterfaces.size();

        // Collect all interfaces (direct + inherited)
        Set<Class<?>> allInterfaces = new HashSet<>();
        collectAllInterfaces(clazz, allInterfaces);
        metrics.totalCount = allInterfaces.size();

        // Calculate inherited count
        metrics.inheritedCount = metrics.totalCount - metrics.directCount;

        // Store interface names for analysis
        metrics.directInterfaceNames = extractInterfaceNames(directInterfaces);
        metrics.allInterfaceNames = extractInterfaceNames(allInterfaces);

        return metrics;
    }

    /**
     * Recursively collects all interfaces implemented by a class hierarchy.
     * 
     * @param clazz      the class to analyze
     * @param interfaces the set to collect interfaces into (modified in place)
     */
    private void collectAllInterfaces(Class<?> clazz, Set<Class<?>> interfaces) {
        if (clazz == null) {
            return;
        }

        // Add direct interfaces of current class
        for (Class<?> iface : clazz.getInterfaces()) {
            interfaces.add(iface);
            // Recursively collect super-interfaces
            collectAllInterfaces(iface, interfaces);
        }

        // Recurse up the class hierarchy
        collectAllInterfaces(clazz.getSuperclass(), interfaces);
    }

    /**
     * Extracts fully qualified names from a set of interface Class objects.
     * 
     * @param interfaces the set of interface classes
     * @return set of fully qualified interface names
     */
    private Set<String> extractInterfaceNames(Set<Class<?>> interfaces) {
        Set<String> names = new HashSet<>();
        for (Class<?> iface : interfaces) {
            names.add(iface.getName());
        }
        return names;
    }

    /**
     * Analyzes interfaces for framework-specific patterns.
     * 
     * @param clazz   the class to analyze
     * @param metrics the metrics object to update
     */
    private void analyzeFrameworkInterfaces(Class<?> clazz, InterfaceMetrics metrics) {
        Set<String> frameworkTypes = new HashSet<>();

        // Check for Spring framework interfaces
        for (String interfaceName : metrics.allInterfaceNames) {
            if (SPRING_INTERFACES.contains(interfaceName)) {
                frameworkTypes.add("Spring");
                metrics.hasFrameworkInterfaces = true;
            }
        }

        // Check for JPA framework interfaces
        for (String interfaceName : metrics.allInterfaceNames) {
            if (JPA_INTERFACES.contains(interfaceName)) {
                frameworkTypes.add("JPA");
                metrics.hasFrameworkInterfaces = true;
            }
        }

        // Check for EJB framework interfaces
        for (String interfaceName : metrics.allInterfaceNames) {
            if (EJB_INTERFACES.contains(interfaceName)) {
                frameworkTypes.add("EJB");
                metrics.hasFrameworkInterfaces = true;
            }
        }

        // Also check annotations (which are interfaces)
        for (java.lang.annotation.Annotation annotation : clazz.getAnnotations()) {
            String annotationType = annotation.annotationType().getName();
            if (SPRING_INTERFACES.contains(annotationType)) {
                frameworkTypes.add("Spring");
                metrics.hasFrameworkInterfaces = true;
            } else if (JPA_INTERFACES.contains(annotationType)) {
                frameworkTypes.add("JPA");
                metrics.hasFrameworkInterfaces = true;
            } else if (EJB_INTERFACES.contains(annotationType)) {
                frameworkTypes.add("EJB");
                metrics.hasFrameworkInterfaces = true;
            }
        }

        metrics.frameworkTypes = frameworkTypes;
    }

    /**
     * Calculates a complexity score based on interface usage patterns.
     * 
     * @param metrics the interface metrics
     * @return calculated complexity score
     */
    private double calculateComplexityScore(InterfaceMetrics metrics) {
        double score = 0.0;

        // Base score from interface counts
        score += metrics.directCount * DIRECT_INTERFACE_WEIGHT;
        score += metrics.inheritedCount * INHERITED_INTERFACE_WEIGHT;

        // Framework interface bonus
        if (metrics.hasFrameworkInterfaces) {
            score += metrics.frameworkTypes.size() * FRAMEWORK_INTERFACE_WEIGHT;
        }

        // Complexity penalty for very high interface counts
        if (metrics.totalCount > COMPLEX_INTERFACE_THRESHOLD * 2) {
            score *= 1.5; // 50% complexity penalty
        }

        return Math.round(score * 100.0) / 100.0; // Round to 2 decimal places
    }

    /**
     * Data class holding calculated interface metrics.
     */
    public static class InterfaceMetrics {
        int totalCount = 0;
        int directCount = 0;
        int inheritedCount = 0;
        double complexityScore = 0.0;
        boolean hasFrameworkInterfaces = false;
        Set<String> frameworkTypes = new HashSet<>();
        Set<String> directInterfaceNames = new HashSet<>();
        Set<String> allInterfaceNames = new HashSet<>();

        public int getTotalCount() {
            return totalCount;
        }

        public int getDirectCount() {
            return directCount;
        }

        public int getInheritedCount() {
            return inheritedCount;
        }

        public double getComplexityScore() {
            return complexityScore;
        }

        public boolean hasFrameworkInterfaces() {
            return hasFrameworkInterfaces;
        }

        public Set<String> getFrameworkTypes() {
            return frameworkTypes;
        }

        public Set<String> getDirectInterfaceNames() {
            return directInterfaceNames;
        }

        public Set<String> getAllInterfaceNames() {
            return allInterfaceNames;
        }
    }
}
