package com.analyzer.rules.metrics;

import com.analyzer.core.export.NodeDecorator;
import com.analyzer.api.inspector.InspectorDependencies;
import com.analyzer.core.inspector.InspectorTags;
import com.analyzer.api.graph.GraphRepository;
import com.analyzer.api.graph.JavaClassNode;
import com.analyzer.core.resource.JARClassLoaderService;
import com.analyzer.dev.inspectors.classloader.AbstractClassLoaderBasedInspector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;

/**
 * Inspector that computes the inheritance depth for Java classes using runtime
 * class loading.
 *
 * <p>
 * This inspector uses the ClassLoader to load classes at runtime and analyze
 * their complete inheritance hierarchy. It calculates the depth as the number
 * of superclasses between the target class and Object (exclusive).
 * </p>
 *
 * <p>
 * Examples:
 * </p>
 * <ul>
 * <li>class A {} → depth = 0 (extends Object implicitly)</li>
 * <li>class B extends A {} → depth = 1</li>
 * <li>class C extends B extends A {} → depth = 2</li>
 * </ul>
 *
 * <p>
 * The computed depth is attached to the JavaClassNode using property keys.
 * </p>
 *
 * <p>
 * Operates in Phase 4 on JavaClassNode objects.
 * </p>
 *
 * @author Generated by EJB Migration Analyzer
 * @since Phase 2.4 - ClassLoader-Based Metrics
 */
@InspectorDependencies(requires = { InspectorTags.TAG_JAVA_DETECTED, InspectorTags.TAG_APPLICATION_CLASS }, produces = {
        "inheritance.depth" })
public class InheritanceDepthInspector extends AbstractClassLoaderBasedInspector {

    private static final Logger logger = LoggerFactory.getLogger(InheritanceDepthInspector.class);

    // Property keys for JavaClassNode metrics
    public static final String PROP_INHERITANCE_DEPTH = "inheritance.depth";
    public static final String PROP_INHERITANCE_IS_DEEP = "inheritance.is_deep";
    public static final String PROP_INHERITANCE_SUPERCLASS_FQN = "inheritance.superclass_fqn";
    public static final String PROP_INHERITANCE_ROOT_CLASS = "inheritance.root_class";

    // Analysis thresholds
    private static final int DEEP_INHERITANCE_THRESHOLD = 3;

    private final GraphRepository graphRepository;

    /**
     * Creates a new InheritanceDepthInspector with required dependencies.
     *
     * @param classLoaderService the service providing the shared ClassLoader
     * @param graphRepository    the graph repository for storing analysis results
     */
    @Inject
    public InheritanceDepthInspector(JARClassLoaderService classLoaderService,
            GraphRepository graphRepository) {
        super(classLoaderService);
        this.graphRepository = graphRepository;
    }

    @Override
    public String getName() {
        return "InheritanceDepthInspector";
    }

    @Override
    protected void analyzeLoadedClass(Class<?> loadedClass, JavaClassNode classNode,
            NodeDecorator<JavaClassNode> decorator) {
        try {
            logger.debug("Analyzing inheritance depth for class: {}", loadedClass.getName());

            // Calculate inheritance metrics
            InheritanceMetrics metrics = calculateInheritanceMetrics(loadedClass);

            // Attach metrics to JavaClassNode
            decorator.setProperty(PROP_INHERITANCE_DEPTH, metrics.depth);
            decorator.setProperty(PROP_INHERITANCE_IS_DEEP, metrics.isDeep);

            if (metrics.immediateSuperclasFqn != null) {
                decorator.setProperty(PROP_INHERITANCE_SUPERCLASS_FQN, metrics.immediateSuperclasFqn);
            }

            if (metrics.rootClass != null) {
                decorator.setProperty(PROP_INHERITANCE_ROOT_CLASS, metrics.rootClass);
            }

            if (metrics.isDeep) {
                decorator.setProperty("inheritance.pattern", "deep_hierarchy");
            }

            logger.debug("Successfully analyzed inheritance depth {} for class: {}",
                    metrics.depth, loadedClass.getName());

        } catch (Exception e) {
            logger.warn("Error analyzing inheritance depth for class: {} - {}",
                    loadedClass.getName(), e.getMessage());
            decorator.error("Failed to analyze inheritance depth: " + e.getMessage());
        }
    }

    /**
     * Calculates comprehensive inheritance metrics for the given class.
     *
     * @param clazz the class to analyze
     * @return inheritance metrics including depth and related properties
     */
    private InheritanceMetrics calculateInheritanceMetrics(Class<?> clazz) {
        InheritanceMetrics metrics = new InheritanceMetrics();

        // Calculate basic inheritance depth
        metrics.depth = calculateInheritanceDepth(clazz);
        metrics.isDeep = metrics.depth > DEEP_INHERITANCE_THRESHOLD;

        // Get immediate superclass information
        Class<?> superclass = clazz.getSuperclass();
        if (superclass != null && !superclass.equals(Object.class)) {
            metrics.immediateSuperclasFqn = superclass.getName();
        }

        // Find root class in hierarchy (excluding Object)
        metrics.rootClass = findRootClass(clazz);

        return metrics;
    }

    /**
     * Calculates the inheritance depth by walking up the class hierarchy.
     *
     * @param clazz the class to analyze
     * @return the number of superclasses between this class and Object (exclusive)
     */
    private int calculateInheritanceDepth(Class<?> clazz) {
        int depth = 0;
        Class<?> current = clazz.getSuperclass();

        while (current != null && !current.equals(Object.class)) {
            depth++;
            current = current.getSuperclass();
        }

        return depth;
    }

    /**
     * Finds the root class in the inheritance hierarchy (excluding Object).
     *
     * @param clazz the class to analyze
     * @return the fully qualified name of the root class, or class itself if no
     *         inheritance
     */
    private String findRootClass(Class<?> clazz) {
        Class<?> current = clazz;
        Class<?> parent = current.getSuperclass();

        // Walk to the top of the hierarchy
        while (parent != null && !parent.equals(Object.class)) {
            current = parent;
            parent = current.getSuperclass();
        }

        return current.getName();
    }

    /**
     * Data class holding calculated inheritance metrics.
     */
    private static class InheritanceMetrics {
        int depth = 0;
        boolean isDeep = false;
        String immediateSuperclasFqn = null;
        String rootClass = null;
    }
}
