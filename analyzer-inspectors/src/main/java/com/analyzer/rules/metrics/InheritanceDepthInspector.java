package com.analyzer.rules.metrics;

import com.analyzer.core.export.NodeDecorator;
import com.analyzer.api.inspector.InspectorDependencies;
import com.analyzer.core.inspector.InspectorTags;
import com.analyzer.api.graph.GraphRepository;
import com.analyzer.api.graph.JavaClassNode;
import com.analyzer.core.model.ProjectFile;
import com.analyzer.core.resource.JARClassLoaderService;
import com.analyzer.dev.inspectors.classloader.AbstractClassLoaderBasedInspector;
import com.analyzer.api.resource.ResourceResolver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;

/**
 * Inspector that computes the inheritance depth for Java classes using runtime
 * class loading.
 *
 * <p>
 * This inspector uses the ClassLoader to load classes at runtime and analyze
 * their complete
 * inheritance hierarchy. It calculates the depth as the number of superclasses
 * between the
 * target class and Object (exclusive).
 * </p>
 *
 * <p>
 * Examples:
 * </p>
 * <ul>
 * <li>class A {} → depth = 0 (extends Object implicitly)</li>
 * <li>class B extends A {} → depth = 1</li>
 * <li>class C extends B extends A {} → depth = 2</li>
 * </ul>
 *
 * <p>
 * The computed depth is attached to the corresponding JavaClassNode using the
 * property key
 * "inheritance.depth". Additional analysis properties are also attached for
 * architectural
 * insights.
 * </p>
 *
 * @author Generated by EJB Migration Analyzer
 * @since Phase 2.4 - ClassLoader-Based Metrics
 */
@InspectorDependencies(requires = { InspectorTags.TAG_JAVA_DETECTED, InspectorTags.TAG_APPLICATION_CLASS }, produces = { "inheritance.depth" })
public class InheritanceDepthInspector extends AbstractClassLoaderBasedInspector {

    private static final Logger logger = LoggerFactory.getLogger(InheritanceDepthInspector.class);

    // Property keys for JavaClassNode metrics
    public static final String PROP_INHERITANCE_DEPTH = "inheritance.depth";
    public static final String PROP_INHERITANCE_IS_DEEP = "inheritance.is_deep";
    public static final String PROP_INHERITANCE_SUPERCLASS_FQN = "inheritance.superclass_fqn";
    public static final String PROP_INHERITANCE_ROOT_CLASS = "inheritance.root_class";

    // Analysis thresholds
    private static final int DEEP_INHERITANCE_THRESHOLD = 3;

    private final GraphRepository graphRepository;

    /**
     * Creates a new InheritanceDepthInspector with required dependencies.
     *
     * @param resourceResolver   the resolver for accessing resources
     * @param classLoaderService the service providing the shared ClassLoader
     * @param graphRepository    the graph repository for storing analysis results
     */
    @Inject
    public InheritanceDepthInspector(ResourceResolver resourceResolver,
            JARClassLoaderService classLoaderService,
            GraphRepository graphRepository) {
        super(resourceResolver, classLoaderService);
        this.graphRepository = graphRepository;
    }

    @Override
    public String getName() {
        return "InheritanceDepthInspector";
    }

    @Override
    protected void analyzeLoadedClass(Class<?> loadedClass, ProjectFile projectFile,
            NodeDecorator<ProjectFile> projectFileDecorator) {
        try {
            logger.debug("Analyzing inheritance depth for class: {}", loadedClass.getName());

            // Calculate inheritance metrics
            InheritanceMetrics metrics = calculateInheritanceMetrics(loadedClass);

            // Attach metrics to JavaClassNode in graph and store as tags
            attachMetricsToGraphNode(projectFile, metrics, projectFileDecorator);

            // Add summary tags for quick access
            projectFileDecorator.setProperty("inheritance.analyzed", "true");

            if (metrics.isDeep) {
                projectFileDecorator.setProperty("inheritance.pattern", "deep_hierarchy");
            }

            logger.debug("Successfully analyzed inheritance depth {} for class: {}",
                    metrics.depth, loadedClass.getName());

        } catch (Exception e) {
            logger.warn("Error analyzing inheritance depth for class: {} - {}",
                    loadedClass.getName(), e.getMessage());
            projectFileDecorator.error("Failed to analyze inheritance depth: " + e.getMessage());
        }
    }

    /**
     * Calculates comprehensive inheritance metrics for the given class.
     *
     * @param clazz the class to analyze
     * @return inheritance metrics including depth and related properties
     */
    private InheritanceMetrics calculateInheritanceMetrics(Class<?> clazz) {
        InheritanceMetrics metrics = new InheritanceMetrics();

        // Calculate basic inheritance depth
        metrics.depth = calculateInheritanceDepth(clazz);
        metrics.isDeep = metrics.depth > DEEP_INHERITANCE_THRESHOLD;

        // Get immediate superclass information
        Class<?> superclass = clazz.getSuperclass();
        if (superclass != null && !superclass.equals(Object.class)) {
            metrics.immediateSuperclasFqn = superclass.getName();
        }

        // Find root class in hierarchy (excluding Object)
        metrics.rootClass = findRootClass(clazz);

        return metrics;
    }

    /**
     * Calculates the inheritance depth by walking up the class hierarchy.
     *
     * @param clazz the class to analyze
     * @return the number of superclasses between this class and Object (exclusive)
     */
    private int calculateInheritanceDepth(Class<?> clazz) {
        int depth = 0;
        Class<?> current = clazz.getSuperclass();

        while (current != null && !current.equals(Object.class)) {
            depth++;
            current = current.getSuperclass();
        }

        return depth;
    }

    /**
     * Finds the root class in the inheritance hierarchy (excluding Object).
     *
     * @param clazz the class to analyze
     * @return the fully qualified name of the root class, or class itself if no
     *         inheritance
     */
    private String findRootClass(Class<?> clazz) {
        Class<?> current = clazz;
        Class<?> parent = current.getSuperclass();

        // Walk to the top of the hierarchy
        while (parent != null && !parent.equals(Object.class)) {
            current = parent;
            parent = current.getSuperclass();
        }

        return current.getName();
    }

    /**
     * Attaches inheritance metrics to the corresponding JavaClassNode in the graph
     * AND aggregates file-level metrics on ProjectFile using MAX strategy.
     *
     * @param projectFile          the project file representing this class
     * @param metrics              the calculated inheritance metrics
     * @param projectFileDecorator the result decorator for storing metrics
     */
    private void attachMetricsToGraphNode(ProjectFile projectFile, InheritanceMetrics metrics,
            NodeDecorator<ProjectFile> projectFileDecorator) {
        String fullyQualifiedName = projectFile.getStringProperty(InspectorTags.PROP_JAVA_FULLY_QUALIFIED_NAME);
        if (fullyQualifiedName == null) {
            logger.warn("Could not find fullyQualifiedName for project file: {}", projectFile.getRelativePath());
            return;
        }

        // LEVEL 1: Store detailed metrics on JavaClassNode (class-level)
        if (graphRepository != null) {
            graphRepository.getNodeById(fullyQualifiedName).ifPresent(node -> {
                if (node instanceof JavaClassNode) {
                    JavaClassNode classNode = (JavaClassNode) node;
                    logger.debug("Attaching inheritance metrics to JavaClassNode: {}", fullyQualifiedName);

                    classNode.setProperty(PROP_INHERITANCE_DEPTH, metrics.depth);
                    classNode.setProperty(PROP_INHERITANCE_IS_DEEP, metrics.isDeep);

                    if (metrics.immediateSuperclasFqn != null) {
                        classNode.setProperty(PROP_INHERITANCE_SUPERCLASS_FQN, metrics.immediateSuperclasFqn);
                    }

                    if (metrics.rootClass != null) {
                        classNode.setProperty(PROP_INHERITANCE_ROOT_CLASS, metrics.rootClass);
                    }

                    logger.debug("Stored inheritance metrics on JavaClassNode: {} (depth={})",
                            fullyQualifiedName, metrics.depth);
                } else {
                    logger.debug("Node found for {} is not a JavaClassNode", fullyQualifiedName);
                }
            });
        } else {
            logger.warn("GraphRepository not available - metrics will be stored on ProjectFile only");
        }

        // Store legacy tags on ProjectFile decorator for backward compatibility
        projectFileDecorator.setProperty(PROP_INHERITANCE_DEPTH, metrics.depth);
        projectFileDecorator.setProperty(PROP_INHERITANCE_IS_DEEP, metrics.isDeep);

        if (metrics.immediateSuperclasFqn != null) {
            projectFileDecorator.setProperty(PROP_INHERITANCE_SUPERCLASS_FQN, metrics.immediateSuperclasFqn);
        }

        if (metrics.rootClass != null) {
            projectFileDecorator.setProperty(PROP_INHERITANCE_ROOT_CLASS, metrics.rootClass);
        }

        // LEVEL 2: Aggregate metrics on ProjectFile (file-level summary)
        // Use MAX strategy - identify the deepest inheritance in this file
        aggregateMaxMetric(projectFile, "inheritance.depth", metrics.depth);

        logger.debug("Aggregated inheritance metrics on ProjectFile: {} (max_depth={}, classes_analyzed={})",
                projectFile.getRelativePath(),
                projectFile.getDoubleProperty("inheritance.depth.max"),
                projectFile.getIntegerProperty("inheritance.depth.classes_analyzed"));
    }

    /**
     * Data class holding calculated inheritance metrics.
     */
    private static class InheritanceMetrics {
        int depth = 0;
        boolean isDeep = false;
        String immediateSuperclasFqn = null;
        String rootClass = null;
    }
}
