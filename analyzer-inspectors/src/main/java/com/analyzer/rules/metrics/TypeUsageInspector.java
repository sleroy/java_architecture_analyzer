package com.analyzer.rules.metrics;

import com.analyzer.core.export.NodeDecorator;
import com.analyzer.api.inspector.InspectorDependencies;
import com.analyzer.core.inspector.InspectorTags;
import com.analyzer.api.graph.GraphRepository;
import javax.inject.Inject;
import com.analyzer.api.graph.JavaClassNode;
import com.analyzer.core.resource.JARClassLoaderService;
import com.analyzer.dev.inspectors.classloader.AbstractClassLoaderBasedInspector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.annotation.Annotation;
import java.lang.reflect.*;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;

/**
 * Inspector that performs comprehensive analysis of type usage within Java
 * classes using runtime class loading.
 * 
 * <p>
 * This inspector analyzes all categories of type usage including field types,
 * method parameter types, return types, exception types, annotation types, and
 * generic type parameters. It provides detailed metrics about type
 * dependencies,
 * complexity, and framework integration patterns.
 * </p>
 * 
 * <p>
 * Type complexity is calculated based on usage patterns, generic complexity,
 * and framework integration. All metrics are attached to the JavaClassNode for
 * architectural analysis.
 * </p>
 * 
 * <p>
 * Operates in Phase 4 on JavaClassNode objects.
 * </p>
 * 
 * @author Generated by EJB Migration Analyzer
 * @since Phase 2.4 - ClassLoader-Based Metrics
 */
@InspectorDependencies(requires = { InspectorTags.TAG_JAVA_DETECTED, InspectorTags.TAG_APPLICATION_CLASS }, produces = {
        "types.total_unique" })
public class TypeUsageInspector extends AbstractClassLoaderBasedInspector {

    private static final Logger logger = LoggerFactory.getLogger(TypeUsageInspector.class);

    // Metrics for JavaClassNode type usage analysis
    public static final String METRIC_TYPES_TOTAL_UNIQUE = "types.total_unique";
    public static final String METRIC_TYPES_FIELD_COUNT = "types.field_count";
    public static final String METRIC_TYPES_PARAMETER_COUNT = "types.parameter_count";
    public static final String METRIC_TYPES_RETURN_COUNT = "types.return_count";
    public static final String METRIC_TYPES_EXCEPTION_COUNT = "types.exception_count";
    public static final String METRIC_TYPES_ANNOTATION_COUNT = "types.annotation_count";
    public static final String METRIC_TYPES_PRIMITIVE_COUNT = "types.primitive_count";
    public static final String METRIC_TYPES_REFERENCE_COUNT = "types.reference_count";
    public static final String METRIC_TYPES_COLLECTION_COUNT = "types.collection_count";
    public static final String METRIC_TYPES_FRAMEWORK_COUNT = "types.framework_count";
    public static final String METRIC_TYPES_COMPLEXITY_SCORE = "types.complexity_score";
    public static final String METRIC_TYPES_GENERIC_COUNT = "types.generic_count";

    // Framework packages for classification
    private static final Set<String> FRAMEWORK_PACKAGES = Set.of(
            "org.springframework", "javax.persistence", "jakarta.persistence",
            "javax.ejb", "jakarta.ejb", "javax.inject", "jakarta.inject",
            "org.hibernate", "org.apache.commons", "com.google.common",
            "org.junit", "org.mockito", "org.slf4j");

    // Collection types for classification
    private static final Set<String> COLLECTION_TYPES = Set.of(
            "java.util.List", "java.util.Set", "java.util.Map", "java.util.Collection",
            "java.util.ArrayList", "java.util.LinkedList", "java.util.HashSet",
            "java.util.TreeSet", "java.util.HashMap", "java.util.TreeMap",
            "java.util.concurrent.ConcurrentHashMap", "java.util.concurrent.CopyOnWriteArrayList");

    private final GraphRepository graphRepository;

    /**
     * Creates a new TypeUsageInspector with required dependencies.
     * 
     * @param classLoaderService the service providing the shared ClassLoader
     * @param graphRepository    the graph repository for storing analysis results
     */
    @Inject
    public TypeUsageInspector(JARClassLoaderService classLoaderService,
            GraphRepository graphRepository) {
        super(classLoaderService);
        this.graphRepository = graphRepository;
    }

    @Override
    public String getName() {
        return "TypeUsageInspector";
    }

    @Override
    protected void analyzeLoadedClass(Class<?> loadedClass, JavaClassNode classNode,
            NodeDecorator<JavaClassNode> decorator) {
        try {
            logger.debug("Analyzing type usage for class: {}", loadedClass.getName());

            // Perform comprehensive type usage analysis
            TypeUsageMetrics metrics = analyzeTypeUsage(loadedClass);

            // Attach metrics to JavaClassNode
            decorator.setMetric(METRIC_TYPES_TOTAL_UNIQUE, metrics.getTotalUniqueTypes());
            decorator.setMetric(METRIC_TYPES_FIELD_COUNT, metrics.getFieldTypeCount());
            decorator.setMetric(METRIC_TYPES_PARAMETER_COUNT, metrics.getParameterTypeCount());
            decorator.setMetric(METRIC_TYPES_RETURN_COUNT, metrics.getReturnTypeCount());
            decorator.setMetric(METRIC_TYPES_EXCEPTION_COUNT, metrics.getExceptionTypeCount());
            decorator.setMetric(METRIC_TYPES_ANNOTATION_COUNT, metrics.getAnnotationTypeCount());
            decorator.setMetric(METRIC_TYPES_PRIMITIVE_COUNT, metrics.getPrimitiveTypeCount());
            decorator.setMetric(METRIC_TYPES_REFERENCE_COUNT, metrics.getReferenceTypeCount());
            decorator.setMetric(METRIC_TYPES_COLLECTION_COUNT, metrics.getCollectionTypeCount());
            decorator.setMetric(METRIC_TYPES_FRAMEWORK_COUNT, metrics.getFrameworkTypeCount());
            decorator.setMetric(METRIC_TYPES_COMPLEXITY_SCORE, metrics.getComplexityScore());
            decorator.setMetric(METRIC_TYPES_GENERIC_COUNT, metrics.getGenericTypeCount());

            decorator.enableTag("type_usage.analyzed");
            decorator.setProperty("type_usage.complexity_level",
                    metrics.getComplexityScore() > 10.0 ? "high"
                            : metrics.getComplexityScore() > 5.0 ? "medium" : "low");

            logger.debug("Successfully analyzed type usage with {} unique types for class: {}",
                    metrics.getTotalUniqueTypes(), loadedClass.getName());

        } catch (Exception e) {
            logger.warn("Error analyzing type usage for class: {}", loadedClass.getName(), e);
            decorator.error("Failed to analyze type usage: " + e.getMessage());
        }
    }

    /**
     * Performs comprehensive type usage analysis for the given class.
     * 
     * @param clazz the class to analyze
     * @return comprehensive type usage metrics
     */
    private TypeUsageMetrics analyzeTypeUsage(Class<?> clazz) {
        TypeUsageMetrics metrics = new TypeUsageMetrics();

        // Analyze different type usage contexts
        analyzeFieldTypes(clazz, metrics);
        analyzeMethodTypes(clazz, metrics);
        analyzeConstructorTypes(clazz, metrics);
        analyzeAnnotationTypes(clazz, metrics);

        // Calculate computed metrics
        metrics.calculateComputedMetrics();

        logger.debug("Type analysis complete for {}: {} unique types, complexity score: {}",
                clazz.getName(), metrics.getTotalUniqueTypes(), metrics.getComplexityScore());

        return metrics;
    }

    /**
     * Analyzes field types including generic type parameters.
     */
    private void analyzeFieldTypes(Class<?> clazz, TypeUsageMetrics metrics) {
        for (Field field : clazz.getDeclaredFields()) {
            Class<?> fieldType = field.getType();
            metrics.addFieldType(fieldType);

            // Handle generic types with recursion protection
            Type genericType = field.getGenericType();
            Set<Type> visitedTypes = new HashSet<>();
            if (genericType instanceof ParameterizedType) {
                analyzeParameterizedTypeSafe((ParameterizedType) genericType, metrics, visitedTypes, 0);
            } else if (genericType instanceof GenericArrayType) {
                analyzeGenericArrayTypeSafe((GenericArrayType) genericType, metrics, visitedTypes, 0);
            }
        }
    }

    /**
     * Analyzes method types including parameters, return types, and exceptions.
     */
    private void analyzeMethodTypes(Class<?> clazz, TypeUsageMetrics metrics) {
        for (Method method : clazz.getDeclaredMethods()) {
            // Return type
            Class<?> returnType = method.getReturnType();
            if (!returnType.equals(void.class)) {
                metrics.addReturnType(returnType);

                // Handle generic return types with recursion protection
                Type genericReturnType = method.getGenericReturnType();
                Set<Type> visitedTypes = new HashSet<>();
                if (genericReturnType instanceof ParameterizedType) {
                    analyzeParameterizedTypeSafe((ParameterizedType) genericReturnType, metrics, visitedTypes, 0);
                }
            }

            // Parameter types
            Class<?>[] parameterTypes = method.getParameterTypes();
            Type[] genericParameterTypes = method.getGenericParameterTypes();

            for (int i = 0; i < parameterTypes.length; i++) {
                metrics.addParameterType(parameterTypes[i]);

                // Handle generic parameter types with recursion protection
                if (i < genericParameterTypes.length &&
                        genericParameterTypes[i] instanceof ParameterizedType) {
                    Set<Type> visitedTypes = new HashSet<>();
                    analyzeParameterizedTypeSafe((ParameterizedType) genericParameterTypes[i], metrics, visitedTypes,
                            0);
                }
            }

            // Exception types
            for (Class<?> exceptionType : method.getExceptionTypes()) {
                metrics.addExceptionType(exceptionType);
            }

            // Type variables from generic methods (with recursion protection)
            Set<Type> visitedTypes = new HashSet<>();
            for (TypeVariable<?> typeVar : method.getTypeParameters()) {
                analyzeTypeVariableSafe(typeVar, metrics, visitedTypes, 0);
            }
        }
    }

    /**
     * Analyzes constructor parameter types.
     */
    private void analyzeConstructorTypes(Class<?> clazz, TypeUsageMetrics metrics) {
        for (Constructor<?> constructor : clazz.getDeclaredConstructors()) {
            Class<?>[] parameterTypes = constructor.getParameterTypes();
            Type[] genericParameterTypes = constructor.getGenericParameterTypes();

            for (int i = 0; i < parameterTypes.length; i++) {
                metrics.addParameterType(parameterTypes[i]);

                // Handle generic parameter types with recursion protection
                if (i < genericParameterTypes.length &&
                        genericParameterTypes[i] instanceof ParameterizedType) {
                    Set<Type> visitedTypes = new HashSet<>();
                    analyzeParameterizedTypeSafe((ParameterizedType) genericParameterTypes[i], metrics, visitedTypes,
                            0);
                }
            }

            // Exception types
            for (Class<?> exceptionType : constructor.getExceptionTypes()) {
                metrics.addExceptionType(exceptionType);
            }
        }
    }

    /**
     * Analyzes annotation types used on the class, fields, and methods.
     */
    private void analyzeAnnotationTypes(Class<?> clazz, TypeUsageMetrics metrics) {
        // Class-level annotations
        for (Annotation annotation : clazz.getDeclaredAnnotations()) {
            metrics.addAnnotationType(annotation.annotationType());
        }

        // Field annotations
        for (Field field : clazz.getDeclaredFields()) {
            for (Annotation annotation : field.getDeclaredAnnotations()) {
                metrics.addAnnotationType(annotation.annotationType());
            }
        }

        // Method annotations
        for (Method method : clazz.getDeclaredMethods()) {
            for (Annotation annotation : method.getDeclaredAnnotations()) {
                metrics.addAnnotationType(annotation.annotationType());
            }

            // Parameter annotations
            for (Annotation[] paramAnnotations : method.getParameterAnnotations()) {
                for (Annotation annotation : paramAnnotations) {
                    metrics.addAnnotationType(annotation.annotationType());
                }
            }
        }

        // Constructor annotations
        for (Constructor<?> constructor : clazz.getDeclaredConstructors()) {
            for (Annotation annotation : constructor.getDeclaredAnnotations()) {
                metrics.addAnnotationType(annotation.annotationType());
            }

            // Constructor parameter annotations
            for (Annotation[] paramAnnotations : constructor.getParameterAnnotations()) {
                for (Annotation annotation : paramAnnotations) {
                    metrics.addAnnotationType(annotation.annotationType());
                }
            }
        }
    }

    /**
     * Analyzes parameterized types with recursion protection.
     */
    private void analyzeParameterizedTypeSafe(ParameterizedType paramType, TypeUsageMetrics metrics,
            Set<Type> visitedTypes, int depth) {
        // Prevent infinite recursion
        if (depth > 10 || visitedTypes.contains(paramType)) {
            return;
        }
        visitedTypes.add(paramType);

        // Add raw type
        Type rawType = paramType.getRawType();
        if (rawType instanceof Class<?>) {
            metrics.addGenericType((Class<?>) rawType);
        }

        // Analyze type arguments recursively with depth tracking
        for (Type typeArg : paramType.getActualTypeArguments()) {
            analyzeGenericTypeArgumentSafe(typeArg, metrics, visitedTypes, depth + 1);
        }
    }

    /**
     * Analyzes generic array types with recursion protection.
     */
    private void analyzeGenericArrayTypeSafe(GenericArrayType arrayType, TypeUsageMetrics metrics,
            Set<Type> visitedTypes, int depth) {
        // Prevent infinite recursion
        if (depth > 10 || visitedTypes.contains(arrayType)) {
            return;
        }
        visitedTypes.add(arrayType);

        Type componentType = arrayType.getGenericComponentType();
        analyzeGenericTypeArgumentSafe(componentType, metrics, visitedTypes, depth + 1);
    }

    /**
     * Analyzes type variables and their bounds with recursion protection.
     */
    private void analyzeTypeVariableSafe(TypeVariable<?> typeVar, TypeUsageMetrics metrics,
            Set<Type> visitedTypes, int depth) {
        // Prevent infinite recursion
        if (depth > 10 || visitedTypes.contains(typeVar)) {
            return;
        }
        visitedTypes.add(typeVar);

        for (Type bound : typeVar.getBounds()) {
            analyzeGenericTypeArgumentSafe(bound, metrics, visitedTypes, depth + 1);
        }
    }

    /**
     * Analyzes generic type arguments recursively with proper termination
     * conditions.
     */
    private void analyzeGenericTypeArgumentSafe(Type type, TypeUsageMetrics metrics,
            Set<Type> visitedTypes, int depth) {
        // Prevent infinite recursion
        if (depth > 10 || visitedTypes.contains(type)) {
            return;
        }

        if (type instanceof Class<?>) {
            metrics.addGenericType((Class<?>) type);
        } else if (type instanceof ParameterizedType) {
            analyzeParameterizedTypeSafe((ParameterizedType) type, metrics, visitedTypes, depth + 1);
        } else if (type instanceof WildcardType) {
            WildcardType wildcardType = (WildcardType) type;
            visitedTypes.add(type);
            for (Type upperBound : wildcardType.getUpperBounds()) {
                analyzeGenericTypeArgumentSafe(upperBound, metrics, visitedTypes, depth + 1);
            }
            for (Type lowerBound : wildcardType.getLowerBounds()) {
                analyzeGenericTypeArgumentSafe(lowerBound, metrics, visitedTypes, depth + 1);
            }
        } else if (type instanceof TypeVariable<?>) {
            analyzeTypeVariableSafe((TypeVariable<?>) type, metrics, visitedTypes, depth + 1);
        } else if (type instanceof GenericArrayType) {
            analyzeGenericArrayTypeSafe((GenericArrayType) type, metrics, visitedTypes, depth + 1);
        }
    }

    /**
     * Data class holding comprehensive type usage metrics.
     */
    public static class TypeUsageMetrics {
        private final Set<Class<?>> fieldTypes = new LinkedHashSet<>();
        private final Set<Class<?>> parameterTypes = new LinkedHashSet<>();
        private final Set<Class<?>> returnTypes = new LinkedHashSet<>();
        private final Set<Class<?>> exceptionTypes = new LinkedHashSet<>();
        private final Set<Class<?>> annotationTypes = new LinkedHashSet<>();
        private final Set<Class<?>> genericTypes = new LinkedHashSet<>();
        private final Set<Class<?>> allTypes = new LinkedHashSet<>();

        // Computed metrics
        private int totalUniqueTypes = 0;
        private int primitiveTypeCount = 0;
        private int referenceTypeCount = 0;
        private int collectionTypeCount = 0;
        private int frameworkTypeCount = 0;
        private int genericTypeCount = 0;
        private double complexityScore = 0.0;

        public void addFieldType(Class<?> type) {
            fieldTypes.add(type);
            allTypes.add(type);
        }

        public void addParameterType(Class<?> type) {
            parameterTypes.add(type);
            allTypes.add(type);
        }

        public void addReturnType(Class<?> type) {
            returnTypes.add(type);
            allTypes.add(type);
        }

        public void addExceptionType(Class<?> type) {
            exceptionTypes.add(type);
            allTypes.add(type);
        }

        public void addAnnotationType(Class<?> type) {
            annotationTypes.add(type);
            allTypes.add(type);
        }

        public void addGenericType(Class<?> type) {
            genericTypes.add(type);
            allTypes.add(type);
        }

        public void calculateComputedMetrics() {
            totalUniqueTypes = allTypes.size();

            for (Class<?> type : allTypes) {
                if (type.isPrimitive()) {
                    primitiveTypeCount++;
                } else {
                    referenceTypeCount++;
                }

                if (COLLECTION_TYPES.contains(type.getName())) {
                    collectionTypeCount++;
                }

                if (isFrameworkType(type)) {
                    frameworkTypeCount++;
                }
            }

            genericTypeCount = genericTypes.size();
            complexityScore = calculateComplexityScore();
        }

        private boolean isFrameworkType(Class<?> type) {
            String typeName = type.getName();
            return FRAMEWORK_PACKAGES.stream().anyMatch(typeName::startsWith);
        }

        private double calculateComplexityScore() {
            double score = 0.0;

            // Base complexity from type counts
            score += primitiveTypeCount * 1.0;
            score += referenceTypeCount * 2.0;
            score += collectionTypeCount * 3.0;
            score += frameworkTypeCount * 2.5;
            score += genericTypeCount * 4.0;

            // Additional complexity from usage diversity
            int categoryCount = 0;
            if (!fieldTypes.isEmpty())
                categoryCount++;
            if (!parameterTypes.isEmpty())
                categoryCount++;
            if (!returnTypes.isEmpty())
                categoryCount++;
            if (!exceptionTypes.isEmpty())
                categoryCount++;
            if (!annotationTypes.isEmpty())
                categoryCount++;

            score += categoryCount * 1.5;

            // Normalize by total types to avoid bias toward large classes
            if (totalUniqueTypes > 0) {
                score = score / Math.sqrt(totalUniqueTypes);
            }

            return Math.round(score * 100.0) / 100.0;
        }

        // Getters
        public int getTotalUniqueTypes() {
            return totalUniqueTypes;
        }

        public int getFieldTypeCount() {
            return fieldTypes.size();
        }

        public int getParameterTypeCount() {
            return parameterTypes.size();
        }

        public int getReturnTypeCount() {
            return returnTypes.size();
        }

        public int getExceptionTypeCount() {
            return exceptionTypes.size();
        }

        public int getAnnotationTypeCount() {
            return annotationTypes.size();
        }

        public int getPrimitiveTypeCount() {
            return primitiveTypeCount;
        }

        public int getReferenceTypeCount() {
            return referenceTypeCount;
        }

        public int getCollectionTypeCount() {
            return collectionTypeCount;
        }

        public int getFrameworkTypeCount() {
            return frameworkTypeCount;
        }

        public int getGenericTypeCount() {
            return genericTypeCount;
        }

        public double getComplexityScore() {
            return complexityScore;
        }

        public Set<Class<?>> getAllTypes() {
            return Collections.unmodifiableSet(allTypes);
        }

        public Set<Class<?>> getFieldTypes() {
            return Collections.unmodifiableSet(fieldTypes);
        }

        public Set<Class<?>> getParameterTypes() {
            return Collections.unmodifiableSet(parameterTypes);
        }

        public Set<Class<?>> getReturnTypes() {
            return Collections.unmodifiableSet(returnTypes);
        }

        public Set<Class<?>> getExceptionTypes() {
            return Collections.unmodifiableSet(exceptionTypes);
        }

        public Set<Class<?>> getAnnotationTypes() {
            return Collections.unmodifiableSet(annotationTypes);
        }

        public Set<Class<?>> getGenericTypes() {
            return Collections.unmodifiableSet(genericTypes);
        }
    }
}
