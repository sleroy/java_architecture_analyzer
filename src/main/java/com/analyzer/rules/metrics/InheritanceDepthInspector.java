package com.analyzer.rules.metrics;

import com.analyzer.core.export.ProjectFileDecorator;
import com.analyzer.core.inspector.InspectorDependencies;
import com.analyzer.core.inspector.InspectorTags;
import com.analyzer.core.graph.GraphRepository;
import com.analyzer.core.graph.JavaClassNode;
import com.analyzer.core.model.ProjectFile;
import com.analyzer.core.resource.JARClassLoaderService;
import com.analyzer.inspectors.core.classloader.AbstractClassLoaderBasedInspector;
import com.analyzer.resource.ResourceResolver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;

/**
 * Inspector that computes the inheritance depth for Java classes using runtime
 * class loading.
 *
 * <p>
 * This inspector uses the ClassLoader to load classes at runtime and analyze
 * their complete
 * inheritance hierarchy. It calculates the depth as the number of superclasses
 * between the
 * target class and Object (exclusive).
 * </p>
 *
 * <p>
 * Examples:
 * </p>
 * <ul>
 * <li>class A {} → depth = 0 (extends Object implicitly)</li>
 * <li>class B extends A {} → depth = 1</li>
 * <li>class C extends B extends A {} → depth = 2</li>
 * </ul>
 *
 * <p>
 * The computed depth is attached to the corresponding JavaClassNode using the
 * property key
 * "inheritance.depth". Additional analysis properties are also attached for
 * architectural
 * insights.
 * </p>
 *
 * @author Generated by EJB Migration Analyzer
 * @since Phase 2.4 - ClassLoader-Based Metrics
 */
@InspectorDependencies(requires = { InspectorTags.TAG_JAVA_DETECTED }, produces = { "inheritance.depth" })
public class InheritanceDepthInspector extends AbstractClassLoaderBasedInspector {

    private static final Logger logger = LoggerFactory.getLogger(InheritanceDepthInspector.class);

    // Property keys for JavaClassNode metrics
    public static final String PROP_INHERITANCE_DEPTH = "inheritance.depth";
    public static final String PROP_INHERITANCE_IS_DEEP = "inheritance.is_deep";
    public static final String PROP_INHERITANCE_SUPERCLASS_FQN = "inheritance.superclass_fqn";
    public static final String PROP_INHERITANCE_ROOT_CLASS = "inheritance.root_class";

    // Analysis thresholds
    private static final int DEEP_INHERITANCE_THRESHOLD = 3;

    private final GraphRepository graphRepository;

    /**
     * Creates a new InheritanceDepthInspector with required dependencies.
     *
     * @param resourceResolver   the resolver for accessing resources
     * @param classLoaderService the service providing the shared ClassLoader
     * @param graphRepository    the graph repository for storing analysis results
     */
    @Inject
    public InheritanceDepthInspector(ResourceResolver resourceResolver,
            JARClassLoaderService classLoaderService,
            GraphRepository graphRepository) {
        super(resourceResolver, classLoaderService);
        this.graphRepository = graphRepository;
    }

    @Override
    public String getName() {
        return "InheritanceDepthInspector";
    }


    @Override
    protected void analyzeLoadedClass(Class<?> loadedClass, ProjectFile projectFile, ProjectFileDecorator projectFileDecorator) {
        try {
            logger.debug("Analyzing inheritance depth for class: {}", loadedClass.getName());

            // Calculate inheritance metrics
            InheritanceMetrics metrics = calculateInheritanceMetrics(loadedClass);

            // Attach metrics to JavaClassNode in graph and store as tags
            attachMetricsToGraphNode(projectFile, metrics, projectFileDecorator);

            // Add summary tags for quick access
            projectFileDecorator.setTag("inheritance.analyzed", "true");

            if (metrics.isDeep) {
                projectFileDecorator.setTag("inheritance.pattern", "deep_hierarchy");
            }

            logger.debug("Successfully analyzed inheritance depth {} for class: {}",
                    metrics.depth, loadedClass.getName());

        } catch (Exception e) {
            logger.warn("Error analyzing inheritance depth for class: {} - {}",
                    loadedClass.getName(), e.getMessage());
            projectFileDecorator.error("Failed to analyze inheritance depth: " + e.getMessage());
        }
    }

    /**
     * Calculates comprehensive inheritance metrics for the given class.
     *
     * @param clazz the class to analyze
     * @return inheritance metrics including depth and related properties
     */
    private InheritanceMetrics calculateInheritanceMetrics(Class<?> clazz) {
        InheritanceMetrics metrics = new InheritanceMetrics();

        // Calculate basic inheritance depth
        metrics.depth = calculateInheritanceDepth(clazz);
        metrics.isDeep = metrics.depth > DEEP_INHERITANCE_THRESHOLD;

        // Get immediate superclass information
        Class<?> superclass = clazz.getSuperclass();
        if (superclass != null && !superclass.equals(Object.class)) {
            metrics.immediateSuperclasFqn = superclass.getName();
        }

        // Find root class in hierarchy (excluding Object)
        metrics.rootClass = findRootClass(clazz);

        return metrics;
    }

    /**
     * Calculates the inheritance depth by walking up the class hierarchy.
     *
     * @param clazz the class to analyze
     * @return the number of superclasses between this class and Object (exclusive)
     */
    private int calculateInheritanceDepth(Class<?> clazz) {
        int depth = 0;
        Class<?> current = clazz.getSuperclass();

        while (current != null && !current.equals(Object.class)) {
            depth++;
            current = current.getSuperclass();
        }

        return depth;
    }

    /**
     * Finds the root class in the inheritance hierarchy (excluding Object).
     *
     * @param clazz the class to analyze
     * @return the fully qualified name of the root class, or class itself if no
     *         inheritance
     */
    private String findRootClass(Class<?> clazz) {
        Class<?> current = clazz;
        Class<?> parent = current.getSuperclass();

        // Walk to the top of the hierarchy
        while (parent != null && !parent.equals(Object.class)) {
            current = parent;
            parent = current.getSuperclass();
        }

        return current.getName();
    }

    /**
     * Attaches inheritance metrics to the corresponding JavaClassNode in the graph.
     * For now, stores metrics as ProjectFileDecorator tags since setProperty is
     * protected.
     *
     * @param projectFile     the project file representing this class
     * @param metrics         the calculated inheritance metrics
     * @param projectFileDecorator the result decorator for storing metrics
     */
    private void attachMetricsToGraphNode(ProjectFile projectFile, InheritanceMetrics metrics,
            ProjectFileDecorator projectFileDecorator) {
        if (graphRepository == null) {
            logger.warn("GraphRepository not available - metrics will be stored as tags only");
        } else {
            String fullyQualifiedName = projectFile.getFullyQualifiedName();
            if (fullyQualifiedName != null) {
                // Verify JavaClassNode exists in graph
                JavaClassNode classNode = (JavaClassNode) graphRepository.getNode(fullyQualifiedName).orElse(null);
                if (classNode != null) {
                    logger.debug("JavaClassNode found in graph for inheritance analysis: {}", fullyQualifiedName);
                    // Note: In future versions, we can extend JavaClassNode with public methods
                    // for setting inheritance-specific properties
                } else {
                    logger.debug("JavaClassNode not found in graph for: {} - metrics stored as tags only",
                            fullyQualifiedName);
                }
            }
        }

        // Store inheritance metrics as detailed tags
        projectFileDecorator.setTag(PROP_INHERITANCE_DEPTH, metrics.depth);
        projectFileDecorator.setTag(PROP_INHERITANCE_IS_DEEP, metrics.isDeep);

        if (metrics.immediateSuperclasFqn != null) {
            projectFileDecorator.setTag(PROP_INHERITANCE_SUPERCLASS_FQN, metrics.immediateSuperclasFqn);
        }

        if (metrics.rootClass != null) {
            projectFileDecorator.setTag(PROP_INHERITANCE_ROOT_CLASS, metrics.rootClass);
        }

        logger.debug("Stored inheritance metrics as tags: {} (depth={})",
                projectFile.getFullyQualifiedName(), metrics.depth);
    }

    /**
     * Data class holding calculated inheritance metrics.
     */
    private static class InheritanceMetrics {
        int depth = 0;
        boolean isDeep = false;
        String immediateSuperclasFqn = null;
        String rootClass = null;
    }
}
