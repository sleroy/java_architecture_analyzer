# Phase: Stateless Session Bean Migration
# Migrates stateless session beans to Spring @Service components

migration-plan:
  phases:
    - id: "phase-stateless-session"
      name: "Stateless Session Bean Migration"
      description: "Migrate stateless session beans to Spring @Service components with @Transactional"
      
      tasks:
        - id: "task-stateless-migration"
          name: "Migrate Stateless Session Beans"
          description: "Convert stateless session beans to Spring services with proper dependency injection"
          
          blocks:
            # Step 1: GRAPH_QUERY - Find all stateless session beans
            - type: "GRAPH_QUERY"
              name: "query-stateless-beans"
              description: "Query all stateless session beans"
              query-type: "BY_TAGS"
              tags:
                - "ejb.stateless.session_bean"
              output-variable: "stateless_beans"
            
            # Step 2: OPENREWRITE - Apply automated refactorings
            - type: "OPENREWRITE"
              name: "refactor-stateless-annotations"
              description: "Replace @Stateless with @Service and update injections"
              recipe: "com.analyzer.ejb2spring.MigrateStatelessSession"
              file-pattern: "**/*.java"
              base-directory: "${refactoring_project_path}/src/main/java"
            
            # Step 3: AI_ASSISTED_BATCH - Process each stateless bean
            - type: "AI_ASSISTED_BATCH"
              name: "ai-migrate-stateless-beans"
              description: "AI-assisted migration for each stateless session bean"
              input-nodes: stateless_beans
              prompt: |
                You are migrating a Stateless Session Bean to a Spring @Service component.
                
                **CRITICAL - TARGET DIRECTORY:**
                **YOU MUST WRITE ALL FILES TO: ${refactoring_project_path}/src/main/java**
                **DO NOT write to the source project paths listed below - those are READ-ONLY references!**
                
                **Current Stateless Session Bean:**
                - Node ID: ${current_node_id}
                - Class Name: ${current_node.simpleName}
                - Fully Qualified Name: ${current_node.fullyQualifiedName}
                - Package: ${current_node.packageName}
                - Migration Complexity: ${current_node.getStringProperty("ejb.session_bean.migrationComplexity", "UNKNOWN")}
                
                **READ-ONLY Source Reference (for reading original code only):**
                <#assign primarySource = current_node.sourceAliasPaths?filter(path -> path?ends_with(".java") && !path?contains("/.analysis/"))?first!"">
                <#if primarySource?has_content>
                - Source to read: ${primarySource}
                </#if>
                
                **WRITE Target (where you MUST write the migrated file):**
                - Target directory: ${refactoring_project_path}/src/main/java
                - Target file path: ${refactoring_project_path}/src/main/java/${current_node.fullyQualifiedName?replace(".", "/")}.java
                
                <#-- Context-aware instructions based on node properties -->
                <#if current_node.hasProperty("factory.bean.analysis")>
                <#assign factoryAnalysis = current_node.getProperty("factory.bean.analysis")>
                <#if (factoryAnalysis.factoryMethodCount > 0)>
                
                **‚ö†Ô∏è FACTORY PATTERN DETECTED:**
                This class has ${factoryAnalysis.factoryMethodCount} factory methods:
                <#list factoryAnalysis.factoryMethods as method>
                - ${method}
                </#list>
                
                **Factory Migration Instructions:**
                - Consider converting factory methods to @Bean methods in a @Configuration class
                - Or keep as static utility methods if they don't need Spring context
                - Ensure thread-safety if factory methods have state
                </#if>
                </#if>
                
                <#if current_node.hasProperty("mutable.service.analysis")>
                <#assign mutableAnalysis = current_node.getProperty("mutable.service.analysis")>
                <#if (mutableAnalysis.mutableFieldCount > 0)>
                
                **‚ö†Ô∏è MUTABLE STATE DETECTED:**
                This stateless bean has ${mutableAnalysis.mutableFieldCount} mutable fields (ANTI-PATTERN in stateless beans):
                <#list mutableAnalysis.mutableFields as field>
                - ${field}
                </#list>
                
                **State Management Instructions:**
                - Stateless beans should NOT have mutable instance state
                - Convert mutable fields to method parameters or request-scoped beans
                - You inject the EntityManager directly into your singleton-scoped (stateless) service or repository class using the standard JPA annotation:
                - If state is truly needed, consider using @Scope("request") or @Scope("prototype")
                - Logger fields are OK as they are thread-safe
                - CDI Event sources (@Inject Event<T>) are OK as they are proxies
                </#if>
                </#if>
                
                <#if current_node.hasProperty("ejb.conversational.state.fields")>
                <#assign stateFields = current_node.getProperty("ejb.conversational.state.fields")>
                <#if (stateFields?size > 0)>
                
                **‚ö†Ô∏è CONVERSATIONAL STATE IN STATELESS BEAN:**
                Found ${stateFields?size} state fields that should not exist in stateless beans:
                <#list stateFields as field>
                - ${field.name} (${field.type})
                </#list>
                
                **Critical:** These fields violate stateless contract. Review and refactor!
                </#if>
                </#if>
                
                <#if current_node.hasProperty("resource.analysis_result")>
                <#assign resourceAnalysis = current_node.getProperty("resource.analysis_result")>
                <#if (resourceAnalysis.dataSourceCount > 0 || resourceAnalysis.resourceRefCount > 0)>
                
                **üìä RESOURCE USAGE DETECTED:**
                - DataSources: ${resourceAnalysis.dataSourceCount}
                - Resource References: ${resourceAnalysis.resourceRefCount}
                - Connection Pool Configs: ${resourceAnalysis.poolConfigCount}
                
                **Resource Migration Instructions:**
                - Replace @Resource DataSource with constructor-injected Spring DataSource
                - Use Spring's application.properties for datasource configuration
                - No JPA/Hibernate - use Spring JdbcTemplate or named ParameterJdbcTemplate
                - Spring Boot will auto-configure connection pool (HikariCP by default)
                </#if>
                </#if>
                
                **Migration Tasks:**
                
                1. **Convert the Java class (source code) to Spring Service:**
                   - Replace @Stateless with @Service
                   - Remove @Local and @Remote interface annotations
                   - Replace @EJB injections with constructor injection (@Autowired or final fields)
                   - Add @Transactional to methods that need transactions
                   - Remove EJB lifecycle methods (@PostConstruct can stay, but remove @PreDestroy if not needed)
                
                2. **Update Dependency Injection:**
                   - Convert all @EJB fields to constructor injection
                   - Use constructor-based dependency injection (preferred in Spring)
                   - Remove any @Resource injections and replace with @Autowired or @Value
                   - Update SessionContext references to use Spring equivalents
                
                3. **Transaction Management:**
                   - Add @Transactional at class level for read-write operations
                   - Use @Transactional(readOnly = true) for read-only operations
                   - Preserve transaction attributes (REQUIRED, REQUIRES_NEW, etc.)
                   - Remove @TransactionAttribute and use Spring's @Transactional properties
                
                4. **Security Migration:**
                   - Replace @RolesAllowed with @PreAuthorize or @Secured
                   - Update @PermitAll to @PreAuthorize("permitAll()")
                   - Convert @DenyAll to @PreAuthorize("denyAll()")
                
                5. **Migration Guidelines:**
                   - Use Jakarta namespace (jakarta.* not javax.*)
                   - Prefer constructor injection over field injection
                   - Make injected fields final
                   - Use Spring's @PostConstruct and @PreDestroy if needed
                   - Document any behavioral changes from EJB to Spring

                6. **JDBC Migration:**
                   - We are NOT using JPA or Hibernate
                   - Database operations are handled by Spring default connection pool
                   - Migrate to Spring JdbcTemplate or NamedParameterJdbcTemplate for database operations 
                   - Use @Transactional for transaction management
                
                **Expected Output:**
                - Spring @Service class with proper annotations
                - Constructor-based dependency injection
                - @Transactional methods
                - Updated security annotations
                - No EJB-specific code remaining
                - Address any anti-patterns identified above
                
                Please migrate this stateless session bean to a Spring service.
              working-directory: "${refactoring_project_path}/src/main/java"
              progress-message: "Migrating stateless session bean"
              timeout-seconds: 600
            
            # Step 4: AI_ASSISTED - Compile and validate
            - type: "AI_ASSISTED"
              name: "compile-stateless-services"
              description: "Compile all migrated stateless services"
              prompt: |
                All stateless session beans have been migrated to Spring services.
                
                **CRITICAL - WORKING DIRECTORY:**
                **You are working in the REFACTORING PROJECT at: ${refactoring_project_path}**
                **Run all Maven commands in: ${refactoring_project_path}**
                **DO NOT run commands in the source project!**
                
                **Summary:**
                - Total beans processed: ${node_count}
                
                **Class IDs:**
                <#list stateless_beans as bean>
                - ${bean}
                </#list>
                
                **Classes:**
                <#list stateless_beans_names as className>
                - ${className}
                </#list>
                
                
                **Tasks:**
                1. Run Maven compile in ${refactoring_project_path} to check for errors
                2. Verify all @EJB references replaced with constructor injection
                3. Check @Transactional annotations are correctly placed
                4. Ensure security annotations are properly configured
                5. Verify Spring context configuration is correct
                6. Fix any circular dependency issues
                7. All files should be in ${refactoring_project_path}/src/main/java
                
                Please compile the classes in ${refactoring_project_path} and fix any errors.
              working-directory: "${refactoring_project_path}"
              timeout-seconds: 300
            
            # Step 5: INTERACTIVE_VALIDATION
            - type: "INTERACTIVE_VALIDATION"
              name: "verify-stateless-migration"
              validation-type: "MANUAL_CONFIRM"
              message: |
                Stateless Session Bean migration completed.
                
                **Migration Summary:**
                - Beans processed: ${node_count}
                
                **Review Checklist:**
                1. All @Stateless replaced with @Service
                2. Constructor injection used for dependencies
                3. @Transactional added to appropriate methods
                4. Security annotations migrated
                5. No EJB imports remaining
                6. All services compile successfully
                7. Spring context properly configured
                
                Please verify and confirm to proceed.
              required: true
              timeout-seconds: 1800
